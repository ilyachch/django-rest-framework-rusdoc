<!-- TRANSLATED by md-translate -->
---

источник:
- validators.py

---

# Валидаторы

> Валидаторы могут быть полезны для повторного использования логики проверки между различными типами полей.
>
> &mdash; [Django documentation](https://docs.djangoproject.com/en/stable/ref/validators/)

В большинстве случаев, когда вы имеете дело с валидацией в REST-фреймворке, вы просто полагаетесь на валидацию полей по умолчанию или пишете явные методы валидации в сериализаторе или классах полей.

Однако иногда вам захочется поместить логику валидации в многоразовые компоненты, чтобы ее можно было легко использовать повторно во всей вашей кодовой базе. Этого можно достичь с помощью функций валидатора и классов валидатора.

## Валидация в REST-фреймворке

Валидация в сериализаторах Django REST framework обрабатывается немного иначе, чем валидация в классе Django `ModelForm`.

В `ModelForm` проверка выполняется частично на форме, а частично на экземпляре модели. В фреймворке REST валидация выполняется полностью на классе сериализатора. Это выгодно по следующим причинам:

* Это вводит надлежащее разделение проблем, делая поведение вашего кода более очевидным.
* Легко переключаться между использованием коротких классов `ModelSerializer` и явными классами `Serializer`. Любое поведение валидации, используемое для `ModelSerializer`, легко воспроизвести.
* Распечатка `repr` экземпляра сериализатора покажет вам, какие именно правила валидации он применяет. Нет никакого дополнительного скрытого поведения валидации, вызываемого на экземпляре модели.

При использовании `ModelSerializer` все это обрабатывается автоматически. Если вы хотите перейти к использованию классов `Serializer`, то вам необходимо явно определить правила валидации.

#### Пример

В качестве примера того, как REST framework использует явную валидацию, возьмем простой класс модели, в котором есть поле с ограничением уникальности.

```
class CustomerReportRecord(models.Model):
    time_raised = models.DateTimeField(default=timezone.now, editable=False)
    reference = models.CharField(unique=True, max_length=20)
    description = models.TextField()
```

Вот базовый `ModelSerializer`, который мы можем использовать для создания или обновления экземпляров `CustomerReportRecord`:

```
class CustomerReportSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomerReportRecord
```

Если мы откроем оболочку Django с помощью `manage.py shell`, то теперь мы можем

```
>>> from project.example.serializers import CustomerReportSerializer
>>> serializer = CustomerReportSerializer()
>>> print(repr(serializer))
CustomerReportSerializer():
    id = IntegerField(label='ID', read_only=True)
    time_raised = DateTimeField(read_only=True)
    reference = CharField(max_length=20, validators=[<UniqueValidator(queryset=CustomerReportRecord.objects.all())>])
    description = CharField(style={'type': 'textarea'})
```

Интересным здесь является поле `reference`. Мы видим, что ограничение уникальности явно обеспечивается валидатором на поле сериализатора.

Из-за этого более явного стиля REST framework включает несколько классов валидаторов, которые недоступны в основном Django. Эти классы подробно описаны ниже.  Валидаторы REST framework, как и их аналоги в Django, реализуют метод `__eq__`, позволяя вам сравнивать экземпляры на равенство.

---

## UniqueValidator

Этот валидатор можно использовать для обеспечения ограничения `unique=True` для полей модели.
Он принимает один обязательный аргумент и необязательный аргумент `messages`:

* `queryset` *required* - Это набор запросов, в отношении которого должна обеспечиваться уникальность.
* `message` - Сообщение об ошибке, которое должно быть использовано при неудачной проверке.
* `lookup` - Поиск, используемый для нахождения существующего экземпляра с проверяемым значением. По умолчанию `'exact''.

Этот валидатор должен применяться к *полям сериализатора*, например, так:

```
from rest_framework.validators import UniqueValidator

slug = SlugField(
    max_length=100,
    validators=[UniqueValidator(queryset=BlogPost.objects.all())]
)
```

## UniqueTogetherValidator

Этот валидатор можно использовать для наложения ограничений `unique_together` на экземпляры модели.
Он имеет два обязательных аргумента и один необязательный аргумент `messages`:

* `queryset` *required* - Это набор запросов, в отношении которого должна обеспечиваться уникальность.
* `fields` *обязательно* - Список или кортеж имен полей, которые должны составлять уникальный набор. Они должны существовать как поля в классе сериализатора.
* `message` - Сообщение об ошибке, которое должно быть использовано при неудачной валидации.

Валидатор должен применяться к классам *сериализаторов*, например, так:

```
from rest_framework.validators import UniqueTogetherValidator

class ExampleSerializer(serializers.Serializer):
    # ...
    class Meta:
        # ToDo items belong to a parent list, and have an ordering defined
        # by the 'position' field. No two items in a given list may share
        # the same position.
        validators = [
            UniqueTogetherValidator(
                queryset=ToDoItem.objects.all(),
                fields=['list', 'position']
            )
        ]
```

---

**Примечание**: Класс `UniqueTogetherValidator` всегда накладывает неявное ограничение на то, что все поля, к которым он применяется, всегда рассматриваются как обязательные. Поля со значениями `default` являются исключением из этого правила, поскольку они всегда предоставляют значение, даже если оно опущено при вводе пользователем.

---

## UniqueForDateValidator

## UniqueForMonthValidator

## UniqueForYearValidator

Эти валидаторы могут быть использованы для наложения ограничений `unique_for_date`, `unique_for_month` и `unique_for_year` на экземпляры модели. Они принимают следующие аргументы:

* `queryset` *required* - Это набор запросов, в отношении которого должна обеспечиваться уникальность.
* `field` *обязательно* - Имя поля, по которому будет проверяться уникальность в заданном диапазоне дат. Оно должно существовать как поле в классе сериализатора.
* `date_field` *обязательно* - Имя поля, которое будет использоваться для определения диапазона дат для ограничения уникальности. Оно должно существовать как поле в классе сериализатора.
* `message` - Сообщение об ошибке, которое должно быть использовано при неудачной валидации.

Валидатор должен применяться к *классам сериализаторов*, например, так:

```
from rest_framework.validators import UniqueForYearValidator

class ExampleSerializer(serializers.Serializer):
    # ...
    class Meta:
        # Blog posts should have a slug that is unique for the current year.
        validators = [
            UniqueForYearValidator(
                queryset=BlogPostItem.objects.all(),
                field='slug',
                date_field='published'
            )
        ]
```

Поле даты, которое используется для валидации, всегда должно присутствовать в классе сериализатора. Вы не можете просто положиться на класс модели `default=...`, потому что значение, используемое по умолчанию, будет создано только после выполнения валидации.

Существует несколько стилей, которые вы можете использовать для этого, в зависимости от того, как вы хотите, чтобы вел себя ваш API. Если вы используете `ModelSerializer`, вы, вероятно, просто будете полагаться на значения по умолчанию, которые REST framework генерирует для вас, но если вы используете `Serializer` или просто хотите более явного контроля, используйте один из стилей, продемонстрированных ниже.

#### Использование с записываемым полем даты.

Если вы хотите, чтобы поле даты было доступно для записи, единственное, что стоит отметить, это то, что вы должны убедиться, что оно всегда доступно во входных данных, либо задав аргумент `default`, либо установив `required=True`.

```
published = serializers.DateTimeField(required=True)
```

#### Использование с полем даты, доступным только для чтения.

Если вы хотите, чтобы поле даты было видимым, но не редактируемым пользователем, то установите `read_only=True` и дополнительно задайте аргумент `default=...`.

```
published = serializers.DateTimeField(read_only=True, default=timezone.now)
```

#### Использование со скрытым полем даты.

Если вы хотите, чтобы поле даты было полностью скрыто от пользователя, используйте `HiddenField`. Этот тип поля не принимает ввод пользователя, а вместо этого всегда возвращает значение по умолчанию в `validated_data` в сериализаторе.

```
published = serializers.HiddenField(default=timezone.now)
```

---

**Примечание**: Классы `UniqueFor<Range>Validator` накладывают неявное ограничение на то, что поля, к которым они применяются, всегда рассматриваются как обязательные. Поля со значениями `default` являются исключением из этого правила, поскольку они всегда предоставляют значение, даже если оно опущено при вводе пользователем.

---

# Расширенные значения полей по умолчанию

Валидаторы, применяемые к нескольким полям в сериализаторе, иногда могут потребовать ввода поля, которое не должно предоставляться клиентом API, но которое *доступно* в качестве ввода для валидатора.

Два шаблона, которые вы можете использовать для такого рода проверки, включают:

* Использование `HiddenField`. Это поле будет присутствовать в `validated_data`, но *не будет* использоваться в выходном представлении сериализатора.
* Использование стандартного поля с `read_only=True`, но которое также включает аргумент `default=...`. Это поле *будет* использоваться в выходном представлении сериализатора, но не может быть задано непосредственно пользователем.

Структура REST включает в себя несколько параметров по умолчанию, которые могут быть полезны в данном контексте.

#### CurrentUserDefault

Класс по умолчанию, который может быть использован для представления текущего пользователя. Чтобы использовать его, 'request' должен быть предоставлен как часть контекстного словаря при инстанцировании сериализатора.

```
owner = serializers.HiddenField(
    default=serializers.CurrentUserDefault()
)
```

#### CreateOnlyDefault

Класс по умолчанию, который можно использовать для *только для установки аргумента по умолчанию во время операций создания*. При обновлении поле опускается.

Он принимает единственный аргумент, который является значением по умолчанию или вызываемой переменной, которая должна использоваться во время операций создания.

```
created_at = serializers.DateTimeField(
    default=serializers.CreateOnlyDefault(timezone.now)
)
```

---

# Ограничения валидаторов

Есть несколько неоднозначных случаев, когда вам нужно будет вместо этого провести валидацию
явно, а не полагаться на классы сериализатора по умолчанию, которые
`ModelSerializer` генерирует.

В этих случаях вы можете захотеть отключить автоматически создаваемые валидаторы,
указав пустой список для атрибута сериализатора `Meta.validators`.

## Необязательные поля

По умолчанию валидация "unique together" принуждает все поля быть
`required=True`. В некоторых случаях вы можете захотеть явно применить
`required=False` к одному из полей, в этом случае желаемое поведение
в этом случае желаемое поведение валидации будет неоднозначным.

В этом случае, как правило, необходимо исключить валидатор из
класса сериализатора, и вместо этого написать логику валидации явно, либо
в методе `.validate()`, либо в представлении.

Например:

```
class BillingRecordSerializer(serializers.ModelSerializer):
    def validate(self, attrs):
        # Apply custom validation either here, or in the view.

    class Meta:
        fields = ['client', 'date', 'amount']
        extra_kwargs = {'client': {'required': False}}
        validators = []  # Remove a default "unique together" constraint.
```

## Обновление вложенных сериализаторов

При применении обновления к существующему экземпляру, валидаторы уникальности будут
исключать текущий экземпляр из проверки уникальности. Текущий экземпляр
доступен в контексте проверки уникальности, поскольку он существует как
атрибут в сериализаторе, поскольку изначально был передан с помощью
`instance=...` при инстанцировании сериализатора.

В случае операций обновления на *вложенных* сериализаторах нет никакого способа
применить это исключение, потому что экземпляр недоступен.

Опять же, вы, вероятно, захотите явно удалить валидатор из
класса сериализатора, и написать код для ограничения валидации
явно, в методе `.validate()` или в представлении.

## Отладка сложных случаев

Если вы не уверены в том, как именно будет вести себя класс `ModelSerializer`.
обычно хорошей идеей является запуск `manage.py shell`, и печать
экземпляр сериализатора, чтобы вы могли проверить поля и
валидаторы, которые он автоматически генерирует для вас.

```
>>> serializer = MyComplexModelSerializer()
>>> print(serializer)
class MyComplexModelSerializer:
    my_fields = ...
```

Также имейте в виду, что в сложных случаях часто лучше явно указать
определить свои классы сериализаторов, а не полагаться на стандартное
`ModelSerializer`. Это требует немного больше кода, но гарантирует
что результирующее поведение будет более прозрачным.

---

# Написание пользовательских валидаторов

Вы можете использовать любой из существующих валидаторов Django или написать свой собственный валидатор.

## Функция основана

Валидатором может быть любой вызываемый объект, который при неудаче выдает `serializers.ValidationError.

```
def even_number(value):
    if value % 2 != 0:
        raise serializers.ValidationError('This field must be an even number.')
```

#### Валидация на полевом уровне

Вы можете задать пользовательскую проверку на уровне полей, добавив методы `.validate_<имя_поля>` в подкласс `Serializer`.
к вашему подклассу `Serializer`. Это документировано в
[Serializer docs](https://www.django-rest-framework.org/api-guide/serializers/#field-level-validation)

## На основе класса

Чтобы написать валидатор на основе класса, используйте метод `__call__`. Валидаторы на основе классов полезны, поскольку позволяют параметризовать и повторно использовать поведение.

```
class MultipleOf:
    def __init__(self, base):
        self.base = base

    def __call__(self, value):
        if value % self.base != 0:
            message = 'This field must be a multiple of %d.' % self.base
            raise serializers.ValidationError(message)
```

#### Доступ к контексту

В некоторых сложных случаях вы можете захотеть, чтобы валидатор передавался сериализатору
поле, с которым он используется, в качестве дополнительного контекста. Вы можете сделать это, установив
атрибут `requires_context = True` для валидатора. Метод `__call__`
будет вызван с полем `serializer_field`
или `serializer` в качестве дополнительного аргумента.

```
requires_context = True

def __call__(self, value, serializer_field):
    ...
```